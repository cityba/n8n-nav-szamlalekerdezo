"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHtmlRenderedContentType = exports.createHtmlSandboxTransformStream = exports.bufferEscapeHtml = exports.sandboxHtmlResponse = exports.hasHtml = void 0;
const jsdom_1 = require("jsdom");
const stream_1 = require("stream");
const hasHtml = (str) => {
    try {
        const dom = new jsdom_1.JSDOM(str);
        return (dom.window.document.body.children.length > 0 || dom.window.document.head.children.length > 0);
    }
    catch {
        return false;
    }
};
exports.hasHtml = hasHtml;
const sandboxHtmlResponse = (data, forceSandbox = false) => {
    let text;
    if (typeof data !== 'string') {
        text = JSON.stringify(data);
    }
    else {
        text = data;
    }
    if (!forceSandbox && !(0, exports.hasHtml)(text)) {
        return text;
    }
    const escapedHtml = text.replaceAll('&', '&amp;').replaceAll('"', '&quot;');
    return `<iframe srcdoc="${escapedHtml}" sandbox="allow-scripts allow-forms allow-popups allow-modals allow-orientation-lock allow-pointer-lock allow-presentation allow-popups-to-escape-sandbox allow-top-navigation-by-user-activation"
			style="position:fixed; top:0; left:0; width:100vw; height:100vh; border:none; overflow:auto;"
			allowtransparency="true"></iframe>`;
};
exports.sandboxHtmlResponse = sandboxHtmlResponse;
const bufferEscapeHtml = (input) => {
    const ampersand = Buffer.from('&', 'utf8').readUInt8(0);
    const escapedAmpersand = Buffer.from('&amp;', 'utf8');
    const doublequote = Buffer.from('"', 'utf8').readUInt8(0);
    const escapedDoublequote = Buffer.from('&quot;', 'utf8');
    let ampersandCount = 0;
    let doublequoteCount = 0;
    for (let i = 0; i < input.length; i++) {
        if (input[i] === ampersand)
            ampersandCount++;
        else if (input[i] === doublequote)
            doublequoteCount++;
    }
    if (ampersandCount === 0 && doublequoteCount === 0)
        return Buffer.from(input);
    const resultLength = input.length +
        ampersandCount * (escapedAmpersand.length - 1) +
        doublequoteCount * (escapedDoublequote.length - 1);
    const output = Buffer.alloc(resultLength);
    let writeOffset = 0;
    for (let i = 0; i < input.length; i++) {
        if (input[i] === ampersand) {
            escapedAmpersand.copy(output, writeOffset);
            writeOffset += escapedAmpersand.length;
        }
        else if (input[i] === doublequote) {
            escapedDoublequote.copy(output, writeOffset);
            writeOffset += escapedDoublequote.length;
        }
        else {
            output[writeOffset++] = input[i];
        }
    }
    return output;
};
exports.bufferEscapeHtml = bufferEscapeHtml;
const createHtmlSandboxTransformStream = () => {
    let isFirstChunk = true;
    const prefix = Buffer.from('<iframe srcdoc="', 'utf8');
    const suffix = Buffer.from('" sandbox="allow-scripts allow-forms allow-popups allow-modals allow-orientation-lock allow-pointer-lock allow-presentation allow-popups-to-escape-sandbox allow-top-navigation-by-user-activation" style="position:fixed; top:0; left:0; width:100vw; height:100vh; border:none; overflow:auto;" allowtransparency="true"></iframe>', 'utf8');
    return new stream_1.Transform({
        transform(chunk, encoding, done) {
            try {
                chunk = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);
                const escapedChunk = (0, exports.bufferEscapeHtml)(chunk);
                const transformedChunk = isFirstChunk
                    ? Buffer.concat([prefix, escapedChunk])
                    : escapedChunk;
                isFirstChunk = false;
                done(null, transformedChunk);
            }
            catch (error) {
                done(error);
            }
        },
        flush(done) {
            try {
                this.push(isFirstChunk ? Buffer.concat([prefix, suffix]) : suffix);
                done();
            }
            catch (error) {
                done(error);
            }
        },
    });
};
exports.createHtmlSandboxTransformStream = createHtmlSandboxTransformStream;
const isHtmlRenderedContentType = (contentType) => {
    const contentTypeLower = contentType.toLowerCase();
    return (contentTypeLower.startsWith('text/html') || contentTypeLower.startsWith('application/xhtml+xml'));
};
exports.isHtmlRenderedContentType = isHtmlRenderedContentType;
//# sourceMappingURL=html-sandbox.js.map