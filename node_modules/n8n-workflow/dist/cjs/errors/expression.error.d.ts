import { ExecutionBaseError } from './abstract/execution-base.error';
export interface ExpressionErrorOptions {
    cause?: Error;
    causeDetailed?: string;
    description?: string;
    descriptionKey?: string;
    descriptionTemplate?: string;
    functionality?: 'pairedItem';
    itemIndex?: number;
    messageTemplate?: string;
    nodeCause?: string;
    parameter?: string;
    runIndex?: number;
    type?: 'no_execution_data' | 'no_node_execution_data' | 'no_input_connection' | 'internal' | 'paired_item_invalid_info' | 'paired_item_no_info' | 'paired_item_multiple_matches' | 'paired_item_no_connection' | 'paired_item_intermediate_nodes';
}
/**
 * Class for instantiating an expression error
 */
export declare const EXPRESSION_ERROR_MESSAGES: {
    readonly NODE_NOT_FOUND: "Error finding the referenced node";
    readonly NODE_REFERENCE_TEMPLATE: "Make sure the node you referenced is spelled correctly and is a parent of this node";
    readonly NO_EXECUTION_DATA: "No execution data available";
};
export declare const EXPRESSION_ERROR_TYPES: {
    readonly PAIRED_ITEM_NO_CONNECTION: "paired_item_no_connection";
};
export declare const EXPRESSION_DESCRIPTION_KEYS: {
    readonly NODE_NOT_FOUND: "nodeNotFound";
    readonly NO_NODE_EXECUTION_DATA: "noNodeExecutionData";
    readonly PAIRED_ITEM_NO_CONNECTION: "pairedItemNoConnection";
    readonly PAIRED_ITEM_NO_CONNECTION_CODE_NODE: "pairedItemNoConnectionCodeNode";
};
export declare class ExpressionError extends ExecutionBaseError {
    constructor(message: string, options?: ExpressionErrorOptions);
}
//# sourceMappingURL=expression.error.d.ts.map