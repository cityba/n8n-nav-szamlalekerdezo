"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.conversationCompactChain = conversationCompactChain;
const messages_1 = require("@langchain/core/messages");
const zod_1 = __importDefault(require("zod"));
async function conversationCompactChain(llm, messages) {
    const CompactedSession = zod_1.default.object({
        summary: zod_1.default.string().describe('A concise summary of the conversation so far'),
        key_decisions: zod_1.default.array(zod_1.default.string()).describe('List of key decisions and actions taken'),
        current_state: zod_1.default.string().describe('Description of the current workflow state'),
        next_steps: zod_1.default.string().describe('Suggested next steps based on the conversation'),
    });
    const modelWithStructure = llm.withStructuredOutput(CompactedSession);
    const conversationText = messages
        .map((msg) => {
        if (msg instanceof messages_1.HumanMessage) {
            return `User: ${msg.content}`;
        }
        else if (msg instanceof messages_1.AIMessage) {
            return `Assistant: ${msg.content ?? 'Used tools'}`;
        }
        return '';
    })
        .filter(Boolean)
        .join('\n');
    const compactPrompt = `Please summarize the following conversation between a user and an AI assistant building an n8n workflow:

${conversationText}

Provide a structured summary that captures the key points, decisions made, current state of the workflow, and suggested next steps.`;
    const structuredOutput = await modelWithStructure.invoke(compactPrompt);
    const compactedMessage = new messages_1.AIMessage({
        content: `## Previous Conversation Summary

**Summary:** ${structuredOutput.summary}

**Key Decisions:**
${structuredOutput.key_decisions.map((d) => `- ${d}`).join('\n')}

**Current State:** ${structuredOutput.current_state}

**Next Steps:** ${structuredOutput.next_steps}`,
    });
    const lastUserMessage = messages.slice(-1);
    const newMessages = [lastUserMessage[0], compactedMessage];
    return {
        success: true,
        summary: structuredOutput,
        newMessages,
        messagesRemoved: messages.length - newMessages.length,
    };
}
//# sourceMappingURL=conversation-compact.js.map