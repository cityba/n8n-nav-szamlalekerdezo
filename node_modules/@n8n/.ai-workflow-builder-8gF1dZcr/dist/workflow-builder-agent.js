"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkflowBuilderAgent = void 0;
const messages_1 = require("@langchain/core/messages");
const langgraph_1 = require("@langchain/langgraph");
const conversation_compact_1 = require("./chains/conversation-compact");
const errors_1 = require("./errors");
const add_node_tool_1 = require("./tools/add-node.tool");
const connect_nodes_tool_1 = require("./tools/connect-nodes.tool");
const node_details_tool_1 = require("./tools/node-details.tool");
const node_search_tool_1 = require("./tools/node-search.tool");
const main_agent_prompt_1 = require("./tools/prompts/main-agent.prompt");
const remove_node_tool_1 = require("./tools/remove-node.tool");
const update_node_parameters_tool_1 = require("./tools/update-node-parameters.tool");
const operations_processor_1 = require("./utils/operations-processor");
const stream_processor_1 = require("./utils/stream-processor");
const tool_executor_1 = require("./utils/tool-executor");
const workflow_state_1 = require("./workflow-state");
class WorkflowBuilderAgent {
    constructor(config) {
        this.parsedNodeTypes = config.parsedNodeTypes;
        this.llmSimpleTask = config.llmSimpleTask;
        this.llmComplexTask = config.llmComplexTask;
        this.logger = config.logger;
        this.checkpointer = config.checkpointer ?? new langgraph_1.MemorySaver();
        this.tracer = config.tracer;
    }
    createWorkflow() {
        const tools = [
            (0, node_search_tool_1.createNodeSearchTool)(this.parsedNodeTypes),
            (0, node_details_tool_1.createNodeDetailsTool)(this.parsedNodeTypes),
            (0, add_node_tool_1.createAddNodeTool)(this.parsedNodeTypes),
            (0, connect_nodes_tool_1.createConnectNodesTool)(this.parsedNodeTypes, this.logger),
            (0, remove_node_tool_1.createRemoveNodeTool)(this.logger),
            (0, update_node_parameters_tool_1.createUpdateNodeParametersTool)(this.parsedNodeTypes, this.llmComplexTask, this.logger),
        ];
        const toolMap = new Map(tools.map((tool) => [tool.name, tool]));
        const callModel = async (state) => {
            if (!this.llmSimpleTask) {
                throw new errors_1.LLMServiceError('LLM not setup');
            }
            if (typeof this.llmSimpleTask.bindTools !== 'function') {
                throw new errors_1.LLMServiceError('LLM does not support tools', {
                    llmModel: this.llmSimpleTask._llmType(),
                });
            }
            const prompt = await main_agent_prompt_1.mainAgentPrompt.invoke({
                ...state,
                executionData: state.workflowContext?.executionData ?? {},
                executionSchema: state.workflowContext?.executionSchema ?? [],
            });
            const response = await this.llmSimpleTask.bindTools(tools).invoke(prompt);
            return { messages: [response] };
        };
        const shouldModifyState = ({ messages }) => {
            const lastMessage = messages[messages.length - 1];
            if (lastMessage.content === '/compact') {
                return 'compact_messages';
            }
            if (lastMessage.content === '/clear') {
                return 'delete_messages';
            }
            return 'agent';
        };
        const shouldContinue = ({ messages }) => {
            const lastMessage = messages[messages.length - 1];
            if (lastMessage.tool_calls?.length) {
                return 'tools';
            }
            return langgraph_1.END;
        };
        const customToolExecutor = async (state) => {
            return await (0, tool_executor_1.executeToolsInParallel)({ state, toolMap });
        };
        function deleteMessages(state) {
            const messages = state.messages;
            const stateUpdate = {
                workflowOperations: null,
                workflowContext: {},
                messages: messages.map((m) => new messages_1.RemoveMessage({ id: m.id })) ?? [],
                workflowJSON: {
                    nodes: [],
                    connections: {},
                },
            };
            return stateUpdate;
        }
        const compactSession = async (state) => {
            if (!this.llmSimpleTask) {
                throw new errors_1.LLMServiceError('LLM not setup');
            }
            const messages = state.messages;
            const compactedMessages = await (0, conversation_compact_1.conversationCompactChain)(this.llmSimpleTask, messages);
            return {
                messages: [
                    ...messages.map((m) => new messages_1.RemoveMessage({ id: m.id })),
                    ...compactedMessages.newMessages,
                ],
            };
        };
        const workflow = new langgraph_1.StateGraph(workflow_state_1.WorkflowState)
            .addNode('agent', callModel)
            .addNode('tools', customToolExecutor)
            .addNode('process_operations', operations_processor_1.processOperations)
            .addNode('delete_messages', deleteMessages)
            .addNode('compact_messages', compactSession)
            .addConditionalEdges('__start__', shouldModifyState)
            .addEdge('tools', 'process_operations')
            .addEdge('process_operations', 'agent')
            .addEdge('delete_messages', langgraph_1.END)
            .addEdge('compact_messages', langgraph_1.END)
            .addConditionalEdges('agent', shouldContinue);
        return workflow;
    }
    async getState(workflowId, userId) {
        const workflow = this.createWorkflow();
        const agent = workflow.compile({ checkpointer: this.checkpointer });
        return await agent.getState({
            configurable: { thread_id: `workflow-${workflowId}-user-${userId ?? new Date().getTime()}` },
        });
    }
    static generateThreadId(workflowId, userId) {
        return workflowId
            ? `workflow-${workflowId}-user-${userId ?? new Date().getTime()}`
            : crypto.randomUUID();
    }
    async *chat(payload, userId) {
        const agent = this.createWorkflow().compile({ checkpointer: this.checkpointer });
        const workflowId = payload.workflowContext?.currentWorkflow?.id;
        const threadId = WorkflowBuilderAgent.generateThreadId(workflowId, userId);
        const threadConfig = {
            configurable: {
                thread_id: threadId,
            },
        };
        const existingCheckpoint = await this.checkpointer.getTuple(threadConfig);
        let stream;
        if (!existingCheckpoint?.checkpoint) {
            const initialState = {
                messages: [new messages_1.HumanMessage({ content: payload.message })],
                workflowJSON: payload.workflowContext?.currentWorkflow ?? {
                    nodes: [],
                    connections: {},
                },
                workflowOperations: [],
                workflowContext: payload.workflowContext,
            };
            stream = await agent.stream(initialState, {
                ...threadConfig,
                streamMode: ['updates', 'custom'],
                recursionLimit: 30,
                callbacks: this.tracer ? [this.tracer] : undefined,
            });
        }
        else {
            const stateUpdate = {
                messages: [new messages_1.HumanMessage({ content: payload.message })],
                workflowOperations: [],
                workflowContext: payload.workflowContext,
                workflowJSON: { nodes: [], connections: {} },
            };
            if (payload.workflowContext?.currentWorkflow) {
                stateUpdate.workflowJSON = payload.workflowContext?.currentWorkflow;
            }
            stream = await agent.stream(stateUpdate, {
                ...threadConfig,
                streamMode: ['updates', 'custom'],
                recursionLimit: 80,
                callbacks: this.tracer ? [this.tracer] : undefined,
            });
        }
        const streamProcessor = (0, stream_processor_1.createStreamProcessor)(stream);
        for await (const output of streamProcessor) {
            yield output;
        }
    }
    async getSessions(workflowId, userId) {
        const sessions = [];
        if (workflowId) {
            const threadId = WorkflowBuilderAgent.generateThreadId(workflowId, userId);
            const threadConfig = {
                configurable: {
                    thread_id: threadId,
                },
            };
            try {
                const checkpoint = await this.checkpointer.getTuple(threadConfig);
                if (checkpoint?.checkpoint) {
                    const messages = checkpoint.checkpoint.channel_values?.messages ?? [];
                    sessions.push({
                        sessionId: threadId,
                        messages: (0, stream_processor_1.formatMessages)(messages),
                        lastUpdated: checkpoint.checkpoint.ts,
                    });
                }
            }
            catch (error) {
                this.logger?.debug('No session found for workflow:', { workflowId, error });
            }
        }
        return { sessions };
    }
}
exports.WorkflowBuilderAgent = WorkflowBuilderAgent;
//# sourceMappingURL=workflow-builder-agent.js.map